# -----------------------------------------Input Parameters------------------------------------------------------------------
from math import hypot
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from copy import deepcopy
from heapq import heappop, heapify, heappush
import matplotlib.ticker as ticker
import time

'Remove and return the lowest priority task. Raise KeyError if empty.'
REMOVED = '<removed-task>'  # placeholder for a removed task

fontsize = 20
fontsize2 = 15
Euro = "eur"
MEuro = "M%s" % Euro

# ---------------------------------------Input--------------------------------------------------------------------------------
# name='random'
# WT_List= [[0, 12667.83342339309, 18000.810230349245], [1, 12251.260426426035, 17158.12834238396], [2, 11789.929002984716, 16710.800281224652], [3, 13231.454551355393, 17822.59514383715], [4, 12493.903732273342, 16091.273919064564], [5, 11281.620675154802, 17174.56503398851], [6, 11871.827643037475, 16016.117657166324], [7, 12728.478576119373, 15481.847210448774], [8, 12243.887154538868, 15144.894619395804], [9, 11230.029992093, 17871.984445294307], [10, 12804.626123955964, 17301.38277364903], [11, 10697.128211536783, 16468.488860345988], [12, 10555.043500451173, 15946.837522352063], [13, 12285.75296598029, 14634.044585957989], [14, 12172.21469991892, 13754.266555671169], [15, 13038.415942683523, 15934.178098029894], [16, 10810.844149653964, 18618.267461202755], [17, 11324.092518900246, 18910.87808281885], [18, 10268.738665858056, 16985.13713060216], [19, 10638.314844326347, 15122.060185776414], [20, 12159.140429670108, 19203.236623585395], [21, 11553.94026012654, 15458.592309441578], [22, 10113.134415661234, 14290.9919922033], [23, 12132.836896543648, 17682.485672655024], [24, 10017.985396922708, 19179.364033311034], [25, 9462.443220085692, 13812.714659182884], [26, 9517.98074669653, 14818.340888370896], [27, 9631.917016328478, 16730.49661608163], [28, 12718.389741268604, 18560.234577995645], [29, 9466.204979349051, 17390.978640739846], [30, 9068.212934545294, 15308.656395728936], [31, 11453.92687902943, 14161.434183134164], [32, 12838.585237585881, 14684.797570580471], [33, 12328.258438032903, 13233.414463583482], [34, 9906.994283355696, 19815.514701185], [35, 11435.122765958122, 13210.051250384342], [36, 12958.224168748993, 19472.51762864674], [37, 8145.316949943754, 15039.04208919331], [38, 13335.56257789214, 14394.014588241633], [39, 10241.78260457898, 13303.22638379492], [40, 13003.883809309009, 13234.488287712076], [41, 9870.568470407286, 18550.846712006998], [42, 9507.483085079066, 15745.030465952337], [43, 13878.05235476709, 14229.943453487715], [44, 12968.489900046608, 16792.450261676993], [45, 13042.19655461275, 18963.527039666256], [46, 9422.726726416391, 19036.17629402336], [47, 13917.83911357518, 13491.354344617617], [48, 12646.065232273584, 20186.0476630362], [49, 10478.054411546767, 19740.636337358268], [50, 8306.942524370254, 15815.718725489663], [51, 9768.3206995144, 17959.074207717462], [52, 13702.265855501772, 15776.398266758091], [53, 11963.534308638042, 12479.280486136351], [54, 13805.55307658129, 16802.728350863643], [55, 9029.145899453877, 15973.653926630455], [56, 8967.316798812026, 14668.338239526152], [57, 13445.59282288435, 20015.719611663895], [58, 8475.756376471649, 18884.04638963838], [59, 12340.66435562482, 20926.21538625059], [60, 11419.940506771969, 20040.07819865632], [61, 14645.634130922203, 16550.079056454688], [62, 15193.790325841206, 16104.420913126232], [63, 14336.181666236047, 20008.668139925045], [64, 7480.131810324741, 14784.737735405073], [65, 14307.66421568696, 17320.837286023932], [66, 10423.710228884796, 18087.92672264988], [67, 15862.339105010658, 15848.187974592858], [68, 12170.089783491578, 18205.782965714778], [69, 12360.784547069981, 11905.930862575615], [70, 14725.177335661792, 14136.381101475126], [71, 7895.578278029192, 14187.22845917808], [72, 9347.703081190146, 18321.26022747323], [73, 8904.379920096906, 19759.70978339146], [74, 10631.512991369063, 14608.431093998292], [75, 9969.448307500345, 15103.442309432268], [76, 6887.5442518165855, 14552.369389873498], [77, 8902.584789885153, 17396.232095589072], [78, 14721.29565997884, 15938.161953837955], [79, 16126.319011269163, 16503.640426378992], [80, 10508.146514801592, 17493.257294091058], [81, 13600.650362102295, 18378.27469213869], [82, 15716.699384571475, 14917.854592107393], [83, 12685.373930835842, 12515.033852723183], [84, 11298.233256668484, 19505.10384308048], [85, 13588.391578494036, 15239.05416073768], [86, 7638.8056839530145, 18678.17716628496], [87, 6281.380440839879, 14591.002209991899], [88, 12711.223061384664, 10990.844548910345], [89, 9961.488685033459, 16076.442085548753], [90, 13127.044849616543, 11958.018207400168], [91, 15441.640101221004, 16620.051534483526], [92, 14838.696003734764, 20137.251680324152], [93, 15394.435297765907, 19387.18005816634], [94, 12071.0637530543, 10505.364267154211], [95, 13424.825177052646, 13850.270101248536], [96, 12911.413434654678, 21384.86711012828], [97, 15137.616582863617, 17212.909454840934], [98, 15977.165604983345, 19088.791760494045], [99, 10022.828881901902, 20461.793402889787]]
# central_platform_locations= [[11203.849726054521, 9505.364267154211]]
name='Borssele'
layout = []
with open("/home/sebasanper/PycharmProjects/IEA_RWP/greedy3.dat", "r") as inp:
    for i, line in enumerate(inp):
        cols = line.split()
        # print cols
        layout.append([i, float(cols[0]), float(cols[1])])

WT_List = layout
# Cable_List=[[8,200],[13,425]]
# name='Sheringham Shoal'
# WT_List=[[0, 371699.5719219753, 5893241.806519924], [1, 371995.3916897116, 5892425.047601489], [2, 372291.3211300142, 5891608.309391071], [3, 372587.40957536316, 5890793.445684481], [4, 372882.4435747459, 5889976.778503153], [5, 373178.701618516, 5889160.102382287], [6, 373474.00324840855, 5888345.330233697], [7, 373769.3649981286, 5887528.724892957], [8, 372367.3944881697, 5892954.9457356], [9, 372662.2826866942, 5892140.113842672], [10, 372958.34498994105, 5891323.419147399], [11, 373253.45153464744, 5890508.6284770295], [12, 373549.7327848602, 5889691.975161428], [13, 373846.12364272366, 5888875.342581324], [14, 374141.5577436912, 5888060.613827967], [15, 374437.0522109928, 5887244.051888607], [16, 373034.2787428773, 5892671.916643782], [17, 373329.2502761629, 5891855.274317262], [18, 373625.44543083035, 5891038.623146914], [19, 373921.7502092533, 5890221.992707997], [20, 374217.09855293424, 5889407.2660823865], [21, 374512.50728671474, 5888590.706263175], [22, 374808.07365863345, 5887776.020843163], [23, 375103.70064295316, 5886959.502243293], [24, 373701.14117933105, 5892385.2741902955], [25, 373997.3598671812, 5891568.645893387], [26, 374292.62244248076, 5890753.9213963365], [27, 374587.9454316481, 5889937.36369809], [28, 374884.54086877685, 5889122.651272739], [29, 375180.0823296546, 5888306.134857392], [30, 375475.73297124443, 5887489.639057397], [31, 375771.49277738784, 5886673.163878971], [32, 374368.1294053509, 5892100.579769947], [33, 374664.4809378369, 5891283.995008986], [34, 374959.8760146963, 5890469.3139023855], [35, 375255.3317519824, 5889652.799600759], [36, 375550.89668603474, 5888836.305910463], [37, 375846.57080069993, 5888019.832837754], [38, 376142.4019959868, 5887205.234185741], [39, 376438.29429617216, 5886388.802366199], [40, 375035.19420472725, 5891815.9795934465], [41, 375331.67857033823, 5890999.4383782], [42, 375627.15797487483, 5890182.94687], [43, 375922.7946111842, 5889368.329776515], [44, 376218.49226561154, 5888551.8795010615], [45, 376514.2990843741, 5887735.449851662], [46, 376810.2150513149, 5886919.040834519], [47, 377105.17218006426, 5886104.534852779], [48, 375702.2874126797, 5891529.619862177], [49, 375997.83832749014, 5890715.004879552], [50, 376294.5649003857, 5889898.527907181], [51, 376589.17142149794, 5889082.129157247], [52, 376885.00172293803, 5888265.722235409], [53, 377180.98869090143, 5887451.189750126], [54, 377477.0371451763, 5886634.824102809], [55, 377772.07915434014, 5885818.507544663], [56, 376369.50559096, 5891245.208191273], [57, 376665.1412246148, 5890428.782812815], [58, 376960.9336758249, 5889614.231864982], [59, 377256.78752666747, 5888797.847740677], [60, 377552.75052549806, 5887981.484253119], [61, 377847.7074089357, 5887165.169837662], [62, 378143.8884662277, 5886348.847570532], [63, 378440.1786230234, 5885532.545958748], [64, 377036.80031198735, 5890960.89078442], [65, 377332.5686802814, 5890144.50882459], [66, 377628.446212595, 5889328.1474975245], [67, 377924.4328927772, 5888511.806809452], [68, 378219.4135821399, 5887695.515110976], [69, 378515.6653140885, 5886881.0694543375], [70, 378810.8635246777, 5886064.818849385], [71, 379107.2861296495, 5885248.560635188], [72, 377704.1241993909, 5890674.8138361825], [73, 378000.0254180379, 5889858.475305391], [74, 378294.9680879301, 5889044.039557952], [75, 378591.0872697145, 5888227.7422435], [76, 378887.31556697463, 5887411.465582661], [77, 379182.5375881144, 5886595.237698214], [78, 379477.86831442814, 5885779.030336655], [79, 379773.3077298053, 5884962.843504098], [80, 378370.45774357766, 5890390.713293606], [81, 378666.49148480647, 5889574.418129274], [82, 378962.63435755007, 5888758.143614624], [83, 379257.7712839471, 5887941.91785935], [84, 379554.1321822215, 5887125.684590942], [85, 379849.4867238326, 5886309.499951179], [86, 380144.94995438034, 5885493.33584266], [87, 380440.5218577546, 5884677.192271525]]
# central_platform_locations=[[374258.98870082205, 5889940.42689391],[377955.9295068521, 5887952.645952081]]
# name='Walney1'
# WT_List=[[0, 470700.0519758684, 5986944.077405927], [1, 470141.4633088345, 5987444.436992147], [2, 469582.66797249735, 5987944.866788965], [3, 469024.1026254509, 5988445.36398708], [4, 468465.438616437, 5988945.74533049], [5, 467906.78507381084, 5989446.010131838], [6, 467348.0354941398, 5989946.530056367], [7, 466789.5146339284, 5990446.931958795], [8, 466230.8951768803, 5990947.218174867], [9, 465672.17988966615, 5991447.759640807], [10, 465113.58423521, 5991948.183913912], [11, 469789.9795978106, 5986643.197601605], [12, 469231.3408848343, 5987143.482083133], [13, 468672.7137743346, 5987643.835381663], [14, 468113.98917418305, 5988144.258277019], [15, 467555.3854293765, 5988644.749309866], [16, 466996.7921153519, 5989145.123813369], [17, 466438.10145080177, 5989645.568040247], [18, 465879.5303444295, 5990145.8950183885], [19, 465320.86196522653, 5990646.291804205], [20, 464762.20546945883, 5991146.757636321], [21, 468879.8944103828, 5986342.12454561], [22, 468321.31721836084, 5986842.704070766], [23, 467762.6399352937, 5987342.982318456], [24, 467203.9755952672, 5987843.51488409], [25, 466645.4294495736, 5988343.744711976], [26, 466086.6780718186, 5988844.230486631], [27, 465528.15534567146, 5989344.598202739], [28, 464969.42617675633, 5989845.036543218], [29, 464410.8179560335, 5990345.543101727], [30, 467969.90799218166, 5986041.228303273], [31, 467411.2792861988, 5986541.547312371], [32, 466852.55432011053, 5987042.121403023], [33, 466293.9488624308, 5987542.578191056], [34, 465735.3537155807, 5988042.918472514], [35, 465176.77025479503, 5988543.32770927], [36, 464617.97887204046, 5989043.62216363], [37, 464059.4189333042, 5989544.169424382], [38, 467059.90989339625, 5985740.324105964], [39, 466501.2321630026, 5986240.7534928145], [40, 465942.56467708654, 5986741.066354277], [41, 465383.9101864116, 5987241.633584609], [42, 464825.26599444373, 5987742.084347507], [43, 464266.6320831295, 5988242.4186718315], [44, 463708.00988654204, 5988742.822019298], [45, 466149.7908435478, 5985439.412703788], [46, 465591.17187489383, 5985939.766267085], [47, 465032.564468099, 5986440.188750061], [48, 464473.9695252009, 5986940.791441247], [49, 463915.27393679344, 5987441.056008246], [50, 463356.59088994766, 5987941.500867804]]
# central_platform_locations=[[467098.75856926845, 5988612]]
# name = "Gwynt"
# # WT_List = [[0, 459441.6993065632, 5926964.419429744], [1, 460159.4141880284, 5926965.736468953],
#            [2, 460877.1271657141, 5926967.162420835], [3, 462486.43410463945, 5927004.189045537],
#            [4, 463204.1360586641, 5927005.966982847], [5, 463921.83615248837, 5927007.854942454],
#            [6, 464639.5204374885, 5927007.997281583], [7, 459086.0987814048, 5926381.527669789],
#            [8, 459805.00877598056, 5926382.780653938], [9, 460522.81107242394, 5926384.153233846],
#            [10, 462128.6911199685, 5926382.149509275], [11, 462846.488192115, 5926383.874683669],
#            [12, 463564.2834566511, 5926385.707661511], [13, 464282.06285378244, 5926385.796139746],
#            [14, 464999.85458896594, 5926387.848061185], [15, 465686.4369191773, 5926356.858553827],
#            [16, 458011.04856699187, 5925756.779953272], [17, 465360.2844421859, 5925767.727252839],
#            [18, 466036.19085211767, 5925777.660575316], [19, 458728.9661202731, 5925759.734183486],
#            [20, 459446.849440374, 5925759.0894157775], [21, 460164.76277837536, 5925762.261498855],
#            [22, 460882.6583926553, 5925763.689099623], [23, 462488.74763033836, 5925761.808498565],
#            [24, 463206.62358592503, 5925761.734189016], [25, 463924.51244198106, 5925763.623325531],
#            [26, 464642.3994130705, 5925765.620271799], [27, 457652.6219922533, 5925135.077222065],
#            [28, 465002.8179645692, 5925143.6194014], [29, 465720.7965519036, 5925145.780335235],
#            [30, 466438.7601660682, 5925146.196781144], [31, 458370.61851795064, 5925136.1241231905],
#            [32, 459088.6132148289, 5925137.278844075], [33, 459806.6060284827, 5925138.543609773],
#            [34, 460524.59707443416, 5925139.917306177], [35, 462130.89942870423, 5925137.916136341],
#            [36, 462848.88530718774, 5925139.641355943], [37, 463566.8692626145, 5925141.4766179025],
#            [38, 464284.85141138954, 5925143.4208082445], [39, 455140.8882686299, 5924507.359209624],
#            [40, 462491.05423146154, 5924517.576865624], [41, 463209.13340153097, 5924519.357133284],
#            [42, 463927.21064463654, 5924521.247449497], [43, 464645.27222487936, 5924521.392176862],
#            [44, 465363.3460545966, 5924523.500361362], [45, 466080.2983354392, 5924523.870883255],
#            [46, 466798.3685826683, 5924526.195654977], [47, 467516.42427016975, 5924526.775944956],
#            [48, 455859.0031731814, 5924509.8789246995], [49, 456577.09871894127, 5924510.654183696],
#            [50, 457295.19239756936, 5924511.538383209], [51, 458013.3007752298, 5924514.384922763],
#            [52, 458731.39061527984, 5924515.487001157], [53, 459449.4785563691, 5924516.696906064],
#            [54, 460167.56474305777, 5924518.016860825], [55, 460884.5427182218, 5924519.454896047],
#            [56, 454783.09740593785, 5923885.862232086], [57, 462133.13041862485, 5923895.538496991],
#            [58, 462851.29019349004, 5923895.4114703825], [59, 463569.4629361687, 5923897.247904224],
#            [60, 464286.5272821167, 5923899.200514524], [61, 465004.69620590063, 5923901.25466409],
#            [62, 465722.84988053585, 5923901.563230896], [63, 466441.01536847855, 5923903.835260341],
#            [64, 467159.16602225247, 5923904.361705294], [65, 467877.327970698, 5923906.850500941],
#            [66, 455501.2901367648, 5923886.474761605], [67, 456219.49821750744, 5923889.049634829],
#            [68, 456937.68701388064, 5923889.88005985], [69, 457654.7675479191, 5923890.829327579],
#            [70, 458372.95278532594, 5923891.87636333], [71, 459091.1522383839, 5923894.887970368],
#            [72, 459809.33348226635, 5923896.152897527], [73, 460527.5129678423, 5923897.527880732],
#            [74, 454425.1963672582, 5923262.538998684], [75, 460887.54160303925, 5923275.212764468],
#            [76, 462493.36866592575, 5923273.346448856], [77, 463211.63655198074, 5923275.12899561],
#            [78, 463928.79590755305, 5923277.028920965], [79, 464647.0462021265, 5923277.174676245],
#            [80, 465365.3086650738, 5923279.282786074], [81, 466083.5693108742, 5923281.500954986],
#            [82, 466800.7083981768, 5923281.9813067345], [83, 467518.96552049485, 5923284.417199748],
#            [84, 468237.20822225633, 5923285.107514451], [85, 455143.5020384612, 5923264.951126042],
#            [86, 455861.7880850936, 5923265.61881533], [87, 456578.96566680324, 5923266.405605838],
#            [88, 457297.26476779475, 5923269.144430551], [89, 458015.54513127415, 5923270.138811441],
#            [90, 458733.8236691888, 5923271.241031625], [91, 459450.9937270475, 5923272.462792289],
#            [92, 460169.26855550567, 5923273.783859739], [93, 454068.3275244537, 5922641.085565572],
#            [94, 460529.31508929486, 5922653.296601454], [95, 462135.3544987852, 5922651.309776112],
#            [96, 462853.71744426084, 5922653.037317613], [97, 463570.9717924201, 5922654.883439328],
#            [98, 464289.3170917119, 5922654.975316793], [99, 465007.674774754, 5922657.030665235],
#            [100, 465724.9237579525, 5922659.201864736], [101, 466443.26445216686, 5922659.620432173],
#            [102, 467161.60387226864, 5922660.14795017], [103, 467878.8477209855, 5922662.646447684],
#            [104, 454785.60391124466, 5922641.601233883], [105, 468597.1841573077, 5922663.391699628],
#            [106, 469315.5311797266, 5922666.100426013], [107, 455504.0027485449, 5922644.068520432],
#            [108, 456221.27528507134, 5922644.801606966], [109, 456939.6527757871, 5922645.63325486],
#            [110, 457658.04509779956, 5922648.4272565935], [111, 458375.3119432416, 5922649.486549818],
#            [112, 459093.6837738591, 5922650.643793212], [113, 459812.0537207237, 5922651.9111071145],
#            [114, 454427.93425863265, 5922051.652827185], [115, 460889.4573377584, 5922032.837725661],
#            [116, 462495.70569930086, 5922030.973986618], [117, 463213.0406294889, 5922030.911783924],
#            [118, 463931.49525155104, 5922032.803179981], [119, 464649.94807148864, 5922034.8046488175],
#            [120, 465367.29205750325, 5922036.923170831], [121, 466085.7278248216, 5922037.287873634],
#            [122, 466799.8514862391, 5922054.479901108], [123, 455146.1075301369, 5922020.691968218],
#            [124, 455863.4752935328, 5922021.371343429], [125, 456581.9651481341, 5922024.002595857],
#            [126, 457299.3290388134, 5922024.899400542], [127, 458017.7980725899, 5922025.893911817],
#            [128, 458736.2814545088, 5922028.853008177], [129, 459453.63961091253, 5922030.074924036],
#            [130, 460172.1028376936, 5922031.397273953], [131, 455505.6001035967, 5921399.82160361],
#            [132, 462856.13804467535, 5921408.81208737], [133, 463573.58076769335, 5921410.659382215],
#            [134, 456224.1851815012, 5921402.399061246], [135, 456941.64401692647, 5921403.242162954],
#            [136, 457660.20815455576, 5921404.184007517], [137, 458377.66336568724, 5921405.243436323],
#            [138, 459096.2238720502, 5921406.403055035], [139, 459813.67544903804, 5921407.681033953],
#            [140, 460532.23221866466, 5921409.0573129505], [141, 462137.6011778128, 5921408.93678312],
#            [142, 456583.8496788125, 5920779.758659322], [143, 457302.5258814839, 5920782.500107177],
#            [144, 458020.0760456584, 5920783.506952609], [145, 458738.73163468577, 5920784.611686777],
#            [146, 459456.2781620802, 5920785.835983101], [147, 460173.8228604673, 5920787.168920322],
#            [148, 460892.4728923558, 5920788.6002486], [149, 462498.0358080813, 5920786.74822472],
#            [150, 457662.3798086427, 5920159.941969918], [151, 458380.03966124955, 5920162.858262983],
#            [152, 459098.78851512796, 5920164.018034596], [153, 459816.428158879, 5920165.297289694],
#            [154, 460534.065969818, 5920166.685191828], [155, 458022.34616628813, 5919539.266698915],
#            [156, 458741.1903897782, 5919540.373804142], [157, 459458.9252508438, 5919541.599369865],
#            [158, 460176.6582733201, 5919542.932476778], [159, 459100.62183842354, 5918964.290601598]]
# central_platform_locations = [[464107.4101949312, 5924210.21681328], [458557.6238058922, 5921094.002139392]]
# name='Barrow'
# WT_List=[[0, 482336.2266630862, 5982594.708765928], [1, 481970.3561861951, 5982926.191039691], [2, 481605.6305661812, 5983257.698080603], [3, 481240.95709241804, 5983589.234042294], [4, 480875.23572541634, 5983918.949087668], [5, 480510.6664877563, 5984250.542967437], [6, 480145.0492268668, 5984580.316095969], [7, 482003.3816064054, 5981861.66062294], [8, 481638.56927666016, 5982193.164367253], [9, 481272.71635482146, 5982524.7014423115], [10, 480908.0007617738, 5982854.408786093], [11, 480542.252218011, 5983186.003958343], [12, 480177.640562582, 5983515.769219947], [13, 479813.08883443486, 5983847.41772664], [14, 479447.4969229777, 5984179.099979807], [15, 481305.5856580518, 5981460.166393137], [16, 480940.7833687051, 5981789.8704492515], [17, 480574.9478557584, 5982121.462326081], [18, 480210.24949078244, 5982451.224306888], [19, 479845.61103064765, 5982782.869533297], [20, 479479.93213005364, 5983114.548501376], [21, 479114.3055426408, 5983446.256551689], [22, 480973.58354318124, 5980725.334077481], [23, 480608.754149417, 5981056.918095737], [24, 480243.969008446, 5981386.676708869], [25, 479878.15082728054, 5981718.32330236], [26, 479513.47779285174, 5982049.994163989], [27, 479147.76414276456, 5982381.698845545], [28, 478783.1870193452, 5982711.573287291], [29, 478417.57776979357, 5983043.336044547]]
# central_platform_locations=[[482283.2420978712, 5982168.408105517]]
NT = len(WT_List)
# List of cable types: [Capacity,Cost] in increasing order (maximum 3 cable types)
Cable_List = [[7, 406 + 365]]
# Choose POS1 or POS2
# option=1 #POS1
option = 1  # POS2
Crossing_penalty = 0
# Area=[[[491858.09, 5725044.65], [502208.11, 5738192.56]], [[508800.53, 5726317.36], [491112.91, 5734678.83]], [[487136.52, 5729617.8], [496459.2, 5732167.05]], [[496459.2, 5732167.05], [500959.72, 5737797.21]], [[494364.31, 5722617.21], [502992.7, 5734016.99]], [[502992.7, 5734016.99], [505471.71, 5734528.44]], [[505471.71, 5734528.44], [506574.97, 5735738.54]], [[501212.81, 5715983.99], [501194.99, 5718210.4]], [[501194.99, 5718210.4], [504863.36, 5738179.94]]]
Area = []
central_platform_locations = [[497278., 5729790.], [501578., 5722390.], [492378., 5725890.]]
#Transmission=[[central_platform_locations[0],[495000,5738000]],[central_platform_locations[1],[495000,5738000]], [central_platform_locations[2],[495000,5738000]]]
Transmission = []


# ---------------------------------------Main--------------------------------------------------------------------------------
def set_cable_topology(NT, WT_List, central_platform_locations, Cable_List):
    Wind_turbines = []
    for WT in WT_List:
        Wind_turbines.append([WT[0] + 1, WT[1], WT[2]])
    # initialize the parameters
    Wind_turbinesi, Costi, Cost0i, Costij, Savingsi, Savingsi_finder, distancefromsubstationi, substationi, Routingi, Routing_redi, Routing_greeni, Pathsi, Capacityi, Cable_Costi, Crossings_finder = dict(), dict(), dict(), dict(), dict(), dict(), dict(), dict(), dict(), dict(), dict(), dict(), dict(), dict(), dict()
    i = 1
    for substation in central_platform_locations:
        Wind_turbinesi[i], Costi[i], distancefromsubstationi[i] = initial_values(Wind_turbines, substation)
        substationi[i] = substation
        i = i + 1
    # splits the Wind_turbines list in the closest substation
    for j in range(NT):
        empty = []
        for key, value in list(distancefromsubstationi.items()):
            empty.append(value[j])
        index = empty.index(min(empty, key=lambda x: x[2])) + 1
        Wind_turbinesi[index].append([value[j][1], Wind_turbines[j][1], Wind_turbines[j][2]])
    for j in range(len(Cable_List)):
        Capacityi[j + 1] = Cable_List[j][0]
        Cable_Costi[j + 1] = Cable_List[j][1]
    # initialize routes and Saving matrix
    for key, value in list(Wind_turbinesi.items()):
        Pathsi[key], Routingi[key], Routing_redi[key], Routing_greeni[key] = initial_routes(value)
        Cost0i[key], Costij[key] = costi(value, substationi[key])
        Savingsi[key], Savingsi_finder[key], Crossings_finder[key] = savingsi(Cost0i[key], Costij[key], value,
                                                                              Cable_Costi[1], substationi[key], Area,
                                                                              Crossing_penalty)
    fig = plt.figure()
    for area in Area:
        plt.plot([area[0][0], area[1][0]], [area[0][1], area[1][1]], color='k', ls='--', linewidth='2')
    for trans in Transmission:
        plt.plot([trans[0][0], trans[1][0]], [trans[0][1], trans[1][1]], color='yellow', linewidth='4')
    cable_length = 0
    total_cost = 0
    crossings = 0
    for key in Wind_turbinesi:
        if option == 1:
            Pathsi[key], Routingi[key], Routing_redi[key], Routing_greeni[key] = POS1_Cable_Choice(Savingsi[key],
                                                                                                   Savingsi_finder[key],
                                                                                                   Crossings_finder[
                                                                                                       key],
                                                                                                   Wind_turbinesi[key],
                                                                                                   Pathsi[key],
                                                                                                   Routingi[key],
                                                                                                   substationi[key],
                                                                                                   Capacityi,
                                                                                                   Routing_redi[key],
                                                                                                   Routing_greeni[key],
                                                                                                   Cable_Costi)
        else:
            Pathsi[key], Routingi[key], Routing_redi[key], Routing_greeni[key] = POS2_Cable_Choice(Savingsi[key],
                                                                                                   Savingsi_finder[key],
                                                                                                   Crossings_finder[
                                                                                                       key],
                                                                                                   Wind_turbinesi[key],
                                                                                                   Pathsi[key],
                                                                                                   Routingi[key],
                                                                                                   substationi[key],
                                                                                                   Capacityi,
                                                                                                   Routing_redi[key],
                                                                                                   Routing_greeni[key],
                                                                                                   Costi[key],
                                                                                                   Cable_Costi)
        Pathsi[key], Routingi[key] = RouteOpt(Routingi[key], substationi[key], Costi[key], Capacityi, Pathsi[key],
                                              Wind_turbinesi[key])
        length, cost, ax = plotting(fig, substationi[key], Wind_turbinesi[key], Routingi[key], Routing_redi[key],
                                    Routing_greeni[key], Capacityi, Cable_Costi)
        cable_length +=length
        total_cost += cost
        for route in Routingi[key]:
            if edge_crossings_area([route[0], route[1]], Wind_turbinesi[key], substationi[key], Area)[0]:
                crossings += edge_crossings_area([route[0], route[1]], Wind_turbinesi[key], substationi[key], Area)[1]
    print(('Cable length = {0} km'.format(round(cable_length / 1000, 3))))
    print(('Cable cost = {0:,} {1}'.format(round(total_cost / 1000000, 3), MEuro)))
    if Area:
        print(('Crossings = {0}'.format(crossings)))

    
    plt.tight_layout()
    plt.subplots_adjust(left=0.06, right=0.94, bottom=0.08)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.title(' {0} OWF - POS{1}+RouteOpt '.format(name, option), fontsize=fontsize)
    plt.grid()
    scale = 1000
    ticks1 = ticker.FuncFormatter(lambda x, pos: '{0:g}'.format(x / scale))
    ax.xaxis.set_major_formatter(ticks1)
    ticks2 = ticker.FuncFormatter(lambda y, pos: '{0:g}'.format(y / scale))
    ax.yaxis.set_major_formatter(ticks2)
    plt.xticks(fontsize=fontsize2)
    plt.yticks(fontsize=fontsize2)
    #plt.show()
    ax.set_autoscale_on(False)
    for j, txt in enumerate(range(1, NT + 1)):
    	ax.annotate(txt, ([item[1]+10 for item in WT_List][j], [item[2]+10 for item in WT_List][j]))
    plt.savefig("topology_ops.eps", format="eps", dpi=1000)

def POS1_Cable_Choice(Savingsi, Savingsi_finder, Crossingsi_finder, Wind_turbinesi, Paths, Routing,
                      central_platform_location, Capacityi, Routing_red, Routing_green, Cable_Costi):
    total_update_red = []
    total_update_green = []
    while True:
        if Savingsi:
            Savingsi, Savingsi_finder, saving = pop_task(Savingsi, Savingsi_finder)
        else:
            break
        if saving is None or saving[0] > 0:
            break
        arc = [saving[1], saving[2]]
        if check_same_path(arc, Paths) is False and any(
                [True for e in [[arc[0], 0]] if e in Routing]) and one_neighbor(arc[1], Paths) is False:
            condition4 = dict()
            for key, value in list(Capacityi.items()):
                condition4[key] = check_capacity(arc, Paths, Capacityi[key])
            if condition4[1] is False and edge_crossings(arc, Wind_turbinesi, central_platform_location,
                                                         Routing) is False and \
                            edge_crossings_area(arc, Wind_turbinesi, central_platform_location, Transmission)[
                                0] is False:
                Routing = []
                for index1, path in enumerate(Paths):
                    if arc[0] == path[1]:
                        Paths[index1].remove(0)
                        break
                for index2, path in enumerate(Paths):
                    if arc[1] == path[-1]:
                        break
                Paths[index2] = Paths[index2] + Paths[index1]
                Paths[index1] = []
                Paths = [path for path in Paths if path != []]
                for i in Paths:
                    for j in range(len(i) - 1):
                        Routing.append([i[j + 1], i[j]])

            if len(condition4) > 1 and condition4[1] == True and condition4[2] == False:
                if edge_crossings_area(arc, Wind_turbinesi, central_platform_location, Transmission)[
                    0] == False and edge_crossings(arc, Wind_turbinesi, central_platform_location, Routing) == False:
                    Paths_temp = deepcopy(Paths)
                    Routing_temp = []
                    total_update_red_temp = []
                    Routing_red_temp = Routing_red
                    for index1, path in enumerate(Paths_temp):
                        if arc[0] == path[1]:
                            Paths_temp[index1].remove(0)
                            break
                    for index2, path in enumerate(Paths_temp):
                        if arc[1] == path[-1]:
                            break
                    Paths_temp[index2] = Paths_temp[index2] + Paths_temp[index1]
                    Paths_temp[index1] = []
                    for i in Paths_temp:
                        if len(i) >= 2:
                            for j in range(len(i) - 1):
                                Routing_temp.append([i[j + 1], i[j]])
                    overcapacity = len(Paths_temp[index2]) - 1 - Capacityi[1]
                    index3 = overcapacity
                    for i in range(index3):
                        total_update_red_temp.append([Paths_temp[index2][i + 1], Paths_temp[index2][i]])
                    total_update_red_temp = renew_update(total_update_red, total_update_red_temp,
                                                         Paths_temp) + total_update_red_temp

                    Routing_red_temp = []
                    for route in total_update_red_temp:
                        for z in range(len(route) - 1):
                            Routing_red_temp.append([route[z], route[z + 1]])
                    new = -(cable_cost(central_platform_location, Wind_turbinesi, Routing, Routing_red, Routing_green,
                                       Cable_Costi) - cable_cost(central_platform_location, Wind_turbinesi,
                                                                 Routing_temp, Routing_red_temp, Routing_green,
                                                                 Cable_Costi))
                    arc1 = [arc[0], 0]
                    new = new + Crossing_penalty * (
                    Crossingsi_finder[(arc[0], arc[1])] - Crossingsi_finder[(arc1[0], arc1[1])])
                    Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (arc[0], arc[1]), new)
                    Savingsi, Savingsi_finder, max_saving = pop_task(Savingsi, Savingsi_finder)
                    if max_saving[0] == new:
                        Paths = Paths_temp
                        Paths = [path for path in Paths if path != []]
                        Routing = Routing_temp
                        Routing_red = Routing_red_temp
                        total_update_red = total_update_red_temp
                    else:
                        Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (max_saving[1], max_saving[2]),
                                                             max_saving[0])

            if len(condition4) > 2 and condition4[1] == True and condition4[2] == True and condition4[3] == False:
                if edge_crossings_area(arc, Wind_turbinesi, central_platform_location, Transmission)[
                    0] == False and edge_crossings(arc, Wind_turbinesi, central_platform_location, Routing) == False:
                    Paths_temp = deepcopy(Paths)
                    Routing_temp = []
                    total_update_green_temp = []
                    total_update_red_temp = []
                    Routing_green_temp = Routing_green
                    for index1, path in enumerate(Paths_temp):
                        if arc[0] == path[1]:
                            Paths_temp[index1].remove(0)
                            break
                    for index2, path in enumerate(Paths_temp):
                        if arc[1] == path[-1]:
                            break
                    Paths_temp[index2] = Paths_temp[index2] + Paths_temp[index1]
                    Paths_temp[index1] = []
                    for i in Paths_temp:
                        if len(i) >= 2:
                            for j in range(len(i) - 1):
                                Routing_temp.append([i[j + 1], i[j]])

                    overcapacity1 = len(Paths_temp[index2]) - 1 - Capacityi[1]
                    overcapacity2 = len(Paths_temp[index2]) - 1 - Capacityi[2]
                    index3 = overcapacity1
                    index4 = overcapacity2
                    for i in range(index4):
                        total_update_green_temp.append([Paths_temp[index2][i + 1], Paths_temp[index2][i]])
                    for i in range(index4, index3):
                        total_update_red_temp.append([Paths_temp[index2][i + 1], Paths_temp[index2][i]])
                    total_update_red_temp = renew_update(total_update_red, total_update_red_temp,
                                                         Paths_temp) + total_update_red_temp
                    total_update_green_temp = renew_update(total_update_green, total_update_green_temp,
                                                           Paths_temp) + total_update_green_temp
                    Routing_red_temp = []
                    for route in total_update_red_temp:
                        for z in range(len(route) - 1):
                            Routing_red_temp.append([route[z], route[z + 1]])
                    Routing_green_temp = []
                    for route in total_update_green_temp:
                        for z in range(len(route) - 1):
                            Routing_green_temp.append([route[z], route[z + 1]])
                    new = -(cable_cost(central_platform_location, Wind_turbinesi, Routing, Routing_red, Routing_green,
                                       Cable_Costi) - cable_cost(central_platform_location, Wind_turbinesi,
                                                                 Routing_temp, Routing_red_temp, Routing_green_temp,
                                                                 Cable_Costi))
                    arc1 = [arc[0], 0]
                    new = new + Crossing_penalty * (
                    Crossingsi_finder[(arc[0], arc[1])] - Crossingsi_finder[(arc1[0], arc1[1])])
                    Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (arc[0], arc[1]), new)
                    Savingsi, Savingsi_finder, max_saving = pop_task(Savingsi, Savingsi_finder)
                    if max_saving[0] == new:
                        Paths = Paths_temp
                        Paths = [path for path in Paths if path != []]
                        Routing = Routing_temp
                        Routing_red = Routing_red_temp
                        Routing_green = Routing_green_temp
                        total_update_red = total_update_red_temp
                        total_update_green = total_update_green_temp
                    else:
                        Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (max_saving[1], max_saving[2]),
                                                             max_saving[0])
    return Paths, Routing, Routing_red, Routing_green


def POS2_Cable_Choice(Savingsi, Savingsi_finder, Crossingsi_finder, Wind_turbinesi, Paths, Routing,
                      central_platform_location, Capacityi, Routing_red, Routing_green, Costi, Cable_Costi):
    total_update_red = []
    total_update_green = []
    while True:
        if Savingsi:
            Savingsi, Savingsi_finder, saving = pop_task(Savingsi, Savingsi_finder)
        else:
            break
        if saving is None or saving[0] > 0:
            break
        arc = [saving[1], saving[2]]
        condition1 = check_same_path(arc, Paths)
        condition21 = any([True for e in [[arc[0], 0]] if e in Routing])
        condition22 = one_neighbor(arc[0], Paths)
        condition3 = one_neighbor(arc[1], Paths)
        if condition1 is False and (condition21 or (condition22 is False)) and condition3 is False:
            condition4 = dict()
            for key, value in list(Capacityi.items()):
                condition4[key] = check_capacity(arc, Paths, Capacityi[key])
            if condition4[1] is False and edge_crossings(arc, Wind_turbinesi, central_platform_location, Routing) is False and edge_crossings_area(arc, Wind_turbinesi, central_platform_location, Transmission)[0] is False:
                Routing = []
                for index1, path in enumerate(Paths):
                    if arc[0] in path:
                        index1 = Paths.index(path)
                        break
                for index2, path in enumerate(Paths):
                    if arc[1] in path:
                        index2 = Paths.index(path)
                        break
                Paths[index1].remove(0)
                if condition21:
                    Paths[index2] = Paths[index2] + Paths[index1]
                    Paths[index1] = []
                elif condition22 is False and condition21 is False:
                    Paths[index1].reverse()
                    Paths[index2] = Paths[index2] + Paths[index1]
                    Paths[index1] = []
                    #               reinsertions start
                    first_client = Paths[index2][-1]
                    for k in Wind_turbinesi:
                        Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (k[0], first_client),
                                                             -(Costi[k[0]][0] - Costi[k[0]][first_client]) *
                                                             Cable_Costi[1])
                u = Paths[index2][-1]
                w = Paths[index2][1]
                Paths = [path for path in Paths if path != []]
                for i in Paths:
                    for j in range(len(i) - 1):
                        Routing.append([i[j + 1], i[j]])
                for n in Wind_turbinesi:
                    value = -(Costi[w][0] - Costi[u][n[0]]) * Cable_Costi[1]
                    if u != n[0]:
                        value = value + Crossing_penalty * (Crossingsi_finder[(u, n[0])] - Crossingsi_finder[(w, 0)])
                    Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (u, n[0]), value)
                heapify(Savingsi)

            if len(condition4) > 1 and condition4[1] == True and condition4[2] == False:
                if edge_crossings_area(arc, Wind_turbinesi, central_platform_location, Transmission)[
                    0] == False and edge_crossings(arc, Wind_turbinesi, central_platform_location, Routing) == False:
                    Paths_temp = deepcopy(Paths)
                    Routing_temp = []
                    total_update_red_temp = []
                    Routing_red_temp = Routing_red
                    for index1, path in enumerate(Paths_temp):
                        if arc[0] in path:
                            index1 = Paths_temp.index(path)
                            break
                    for index2, path in enumerate(Paths_temp):
                        if arc[1] in path:
                            index2 = Paths_temp.index(path)
                            break
                    Paths_temp[index1].remove(0)
                    if condition21 == True:
                        Paths_temp[index2] = Paths_temp[index2] + Paths_temp[index1]
                    elif condition22 == False and condition21 == False:
                        Paths_temp[index1].reverse()
                        Paths_temp[index2] = Paths_temp[index2] + Paths_temp[index1]
                    Paths_temp[index1] = []
                    for i in Paths_temp:
                        if len(i) >= 2:
                            for j in range(len(i) - 1):
                                Routing_temp.append([i[j + 1], i[j]])
                    overcapacity = len(Paths_temp[index2]) - 1 - Capacityi[1]
                    index3 = overcapacity
                    for i in range(0, index3):
                        total_update_red_temp.append([Paths_temp[index2][i + 1], Paths_temp[index2][i]])
                    total_update_red_temp = renew_update(total_update_red, total_update_red_temp,
                                                         Paths_temp) + total_update_red_temp
                    Routing_red_temp = []
                    for route in total_update_red_temp:
                        for z in range(0, len(route) - 1):
                            Routing_red_temp.append([route[z], route[z + 1]])
                    new = -(cable_cost(central_platform_location, Wind_turbinesi, Routing, Routing_red, Routing_green,
                                       Cable_Costi) - cable_cost(central_platform_location, Wind_turbinesi,
                                                                 Routing_temp, Routing_red_temp, Routing_green,
                                                                 Cable_Costi))
                    w = Paths_temp[index2][1]
                    new += Crossing_penalty * (Crossingsi_finder[(arc[0], arc[1])] - Crossingsi_finder[(w, 0)])
                    Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (arc[0], arc[1]), new)
                    Savingsi, Savingsi_finder, max_saving = pop_task(Savingsi, Savingsi_finder)
                    if max_saving[0] == new:
                        Paths = Paths_temp
                        Routing = Routing_temp
                        Routing_red = Routing_red_temp
                        total_update_red = total_update_red_temp
                        u = Paths[index2][-1]
                        w = Paths[index2][1]
                        Paths = [path for path in Paths if path != []]
                        for n in Wind_turbinesi:
                            if one_neighbor(n[0], Paths) == False:
                                value = -(Costi[w][0] - Costi[u][n[0]]) * Cable_Costi[1]
                                if u != n[0]:
                                    value = value + Crossing_penalty * (
                                    Crossingsi_finder[(u, n[0])] - Crossingsi_finder[(w, 0)])
                                Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (u, n[0]), value)
                        heapify(Savingsi)
                    else:
                        Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (max_saving[1], max_saving[2]),
                                                             max_saving[0])

            if len(condition4) > 2 and condition4[1] == True and condition4[2] == True and condition4[3] == False:
                if edge_crossings_area(arc, Wind_turbinesi, central_platform_location, Transmission)[
                    0] == False and edge_crossings(arc, Wind_turbinesi, central_platform_location, Routing) == False:
                    Paths_temp = deepcopy(Paths)
                    Routing_temp = []
                    total_update_green_temp = []
                    total_update_red_temp = []
                    Routing_green_temp = Routing_green
                    for index1, path in enumerate(Paths_temp):
                        if arc[0] in path:
                            index1 = Paths_temp.index(path)
                            break
                    for index2, path in enumerate(Paths_temp):
                        if arc[1] in path:
                            index2 = Paths_temp.index(path)
                            break
                    Paths_temp[index1].remove(0)
                    if condition21 == True:
                        Paths_temp[index2] = Paths_temp[index2] + Paths_temp[index1]
                    elif condition22 == False and condition21 == False:
                        Paths_temp[index1].reverse()
                        Paths_temp[index2] = Paths_temp[index2] + Paths_temp[index1]
                    Paths_temp[index1] = []
                    for i in Paths_temp:
                        if len(i) >= 2:
                            for j in range(len(i) - 1):
                                Routing_temp.append([i[j + 1], i[j]])
                    overcapacity1 = len(Paths_temp[index2]) - 1 - Capacityi[1]
                    overcapacity2 = len(Paths_temp[index2]) - 1 - Capacityi[2]
                    index3 = overcapacity1
                    index4 = overcapacity2
                    for i in range(0, index4):
                        total_update_green_temp.append([Paths_temp[index2][i + 1], Paths_temp[index2][i]])
                    for i in range(index4, index3):
                        total_update_red_temp.append([Paths_temp[index2][i + 1], Paths_temp[index2][i]])
                    total_update_red_temp = renew_update(total_update_red, total_update_red_temp,
                                                         Paths_temp) + total_update_red_temp
                    total_update_green_temp = renew_update(total_update_green, total_update_green_temp,
                                                           Paths_temp) + total_update_green_temp
                    Routing_red_temp = []
                    for route in total_update_red_temp:
                        for z in range(0, len(route) - 1):
                            Routing_red_temp.append([route[z], route[z + 1]])
                    Routing_green_temp = []
                    for route in total_update_green_temp:
                        for z in range(0, len(route) - 1):
                            Routing_green_temp.append([route[z], route[z + 1]])
                    new = -(cable_cost(central_platform_location, Wind_turbinesi, Routing, Routing_red, Routing_green,
                                       Cable_Costi) - cable_cost(central_platform_location, Wind_turbinesi,
                                                                 Routing_temp, Routing_red_temp, Routing_green_temp,
                                                                 Cable_Costi))
                    w = Paths_temp[index2][1]
                    new = new + Crossing_penalty * (Crossingsi_finder[(arc[0], arc[1])] - Crossingsi_finder[(w, 0)])
                    Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (arc[0], arc[1]), new)
                    Savingsi, Savingsi_finder, max_saving = pop_task(Savingsi, Savingsi_finder)
                    if max_saving[0] == new:
                        Paths = Paths_temp
                        Routing = Routing_temp
                        Routing_red = Routing_red_temp
                        Routing_green = Routing_green_temp
                        total_update_red = total_update_red_temp
                        total_update_green = total_update_green_temp
                        u = Paths[index2][-1]
                        w = Paths[index2][1]
                        Paths = [path for path in Paths if path != []]
                        for n in Wind_turbinesi:
                            if one_neighbor(n[0], Paths) == False:
                                value = -(Costi[w][0] - Costi[u][n[0]]) * Cable_Costi[1]
                                if u != n[0]:
                                    value = value + Crossing_penalty * (
                                    Crossingsi_finder[(u, n[0])] - Crossingsi_finder[(w, 0)])
                                Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (u, n[0]), value)
                        heapify(Savingsi)
                    else:
                        Savingsi, Savingsi_finder = add_task(Savingsi, Savingsi_finder, (max_saving[1], max_saving[2]),
                                                             max_saving[0])
    return Paths, Routing, Routing_red, Routing_green


def renew_update(total_update, total_update_temp, Paths_temp):
    indeces = []
    for indexerase, route in enumerate(total_update):
        for turbine in route:
            if turbine != 0:
                for pair in total_update_temp:
                    if (pair[0] != 0 and pair[1] == 0) or (pair[0] == 0 and pair[1] != 0):
                        same1 = [turbine, pair[0]]
                    if pair[0] != 0 and pair[1] != 0:
                        same1 = [turbine, pair[0]]
                        same2 = [turbine, pair[1]]
                        if check_same_path(same1, Paths_temp) == True or check_same_path(same2, Paths_temp) == True:
                            if indexerase not in indeces:
                                indeces.append(indexerase)
    if indeces != []:
        for i in indeces:
            total_update[i] = []
    for pair in total_update[:]:
        if pair == []:
            total_update.remove(pair)
    return total_update


def RouteOpt(Routing, central_platform_location, Costi, Capacityi, Paths, Wind_turbinesi):
    list = []
    for index, path in enumerate(Paths):
        if len(path) - 1 <= Capacityi[1]:
            path.reverse()
            cond = True
            while cond == True:
                for l in range(1, len(path)):
                    list.append([Costi[path[l - 1]][path[l]] - Costi[path[l]][path[0]], path[0], path[l]])
                s = max(list, key=lambda x: x[0])
                if s[0] > 0 and edge_crossings([s[1], s[2]], Wind_turbinesi, central_platform_location,
                                               Routing) == False and \
                                edge_crossings_area([s[1], s[2]], Wind_turbinesi, central_platform_location,
                                                    Transmission)[0] == False:
                    for lamd, k in enumerate(list):
                        if k == s:
                            xmm = lamd + 1
                            path1 = path[:xmm]
                            path2 = path[xmm:]
                            path1.reverse()
                            path = path1 + path2
                            Paths[index] = path
                            list = []
                            cond = True
                else:
                    list = []
                    cond = False
        elif len(path) - 1 > Capacityi[1]:
            path.reverse()
            cond = True
            while cond == True:
                for l in range(1, len(path)):
                    list.append([Costi[path[l - 1]][path[l]] - Costi[path[l]][path[0]], path[0], path[l]])
                s = max(list, key=lambda x: x[0])
                if s[0] > 0 and edge_crossings([s[1], s[2]], Wind_turbinesi, central_platform_location,
                                               Routing) == False:
                    for lamd, k in enumerate(list):
                        if k == s:
                            xmm = lamd + 1
                            path1 = path[:xmm]
                            path2 = path[xmm:]
                            path1.reverse()
                            path = path1 + path2
                            Paths[index] = path
                            list = []
                            cond = True
                else:
                    list = []
                    cond = False
    Routing = []
    for i in Paths:
        i.reverse()
        for j in range(len(i) - 1):
            Routing.append([i[j + 1], i[j]])
    return Paths, Routing


def initial_values(Wind_turbines, central_platform_location):
    Costi = [[0 for i in range(NT + 1)] for j in range(NT + 1)]
    set_cost_matrix(Costi, Wind_turbines, central_platform_location)
    distancefromsubstationi = [[0, i + 1, Costi[0][i + 1]] for i in range(len(Costi[0]) - 1)]
    Wind_turbinesi = []
    return Wind_turbinesi, Costi, distancefromsubstationi


def initial_routes(Wind_turbinesi):
    Routing_greeni = []
    Routing_redi = []
    Routingi = []
    Pathsi = []
    for WT in Wind_turbinesi:
        Routingi.append([WT[0], 0])
        Pathsi.append([0, WT[0]])
    return Pathsi, Routingi, Routing_redi, Routing_greeni


def costi(Wind_turbinesi, central_platform_location):
    Cost0i = []
    Costij = []
    for i in Wind_turbinesi:
        Cost0i.append([0, i[0], hypot(central_platform_location[0] - i[1], central_platform_location[1] - i[2])])
        for j in Wind_turbinesi:
            if i != j:
                Costij.append([i[0], j[0], hypot(i[1] - j[1], i[2] - j[2])])
    return Cost0i, Costij


def savingsi(Cost0i, Costij, Wind_turbinesi, Cable_Cost1, central_platform_location, Area, Crossing_penalty):
    Savingsi = []
    Savingsi_finder = {}
    Crossingsi_finder = {}
    counter = 0
    for i in zip(*Wind_turbinesi)[0]:
        k = Cost0i[counter]
        step = (len(Wind_turbinesi) - 1) * counter
        for j in range(step, step + len(Wind_turbinesi) - 1):
            saving = -(k[2] - Costij[j][2]) * Cable_Cost1
            arc1 = [i, 0]
            arc2 = [i, Costij[j][1]]
            crossings_arc1 = edge_crossings_area(arc1, Wind_turbinesi, central_platform_location, Area)[1]
            crossings_arc2 = edge_crossings_area(arc2, Wind_turbinesi, central_platform_location, Area)[1]
            Crossingsi_finder[(arc1[0], arc1[1])] = crossings_arc1
            Crossingsi_finder[(arc2[0], arc2[1])] = crossings_arc2
            saving = saving + Crossing_penalty * (crossings_arc2 - crossings_arc1)
            if saving < 0:
                add_task(Savingsi, Savingsi_finder, (i, Costij[j][1]), saving)
        counter += 1
    return Savingsi, Savingsi_finder, Crossingsi_finder


def add_task(Savings, entry_finder, task, priority):
    'Add a new task or update the priority of an existing task'
    if task in entry_finder:
        entry_finder = remove_task(entry_finder, task)
    entry = [priority, task[0], task[1]]
    entry_finder[(task[0], task[1])] = entry
    heappush(Savings, entry)
    return Savings, entry_finder


def remove_task(entry_finder, task):
    entry = entry_finder.pop(task)
    entry[0] = REMOVED
    return entry_finder


def pop_task(Savings, entry_finder):
    while Savings:
        saving = heappop(Savings)
        if saving[0] is not REMOVED:
            del entry_finder[(saving[1], saving[2])]
            return Savings, entry_finder, saving


def set_cost_matrix(Cost, Wind_turbines, central_platform_location):
    Cost[0][0] = float('inf')
    for i in Wind_turbines:
        Cost[0][i[0]] = hypot(central_platform_location[0] - i[1], central_platform_location[1] - i[2])
        Cost[i[0]][0] = hypot(central_platform_location[0] - i[1], central_platform_location[1] - i[2])
        for j in Wind_turbines:
            if i == j:
                Cost[i[0]][j[0]] = float('inf')
            else:
                Cost[i[0]][j[0]] = hypot(i[1] - j[1], i[2] - j[2])


# Subroutine 4, check if two turbines in the same arc are in the same path
def check_same_path(arc, Paths):
    same_path = False
    for path in Paths:
        if arc[0] in path and arc[1] in path:
            same_path = True
            break
    return same_path


# Subroutine 5, check if turbine u has only one neighbor in Routing
def one_neighbor(turbine, Paths):
    more_than_one = False
    for path in Paths:
        if turbine in path and turbine != path[-1]:
            more_than_one = True
            break
    return more_than_one


def check_capacity(arc, Paths, Capacity):
    cap_exceeded = False
    turbines_in_branch = 0
    for path in Paths:
        if arc[0] in path or arc[1] in path:
            turbines_in_branch = turbines_in_branch + (len(path) - 1)
            if turbines_in_branch > Capacity:
                cap_exceeded = True
                break
    return cap_exceeded


def edge_crossings(arc, Wind_turbines, central_platform_location, Routing):
    x1, y1 = give_coordinates(arc[0], Wind_turbines, central_platform_location)
    x2, y2 = give_coordinates(arc[1], Wind_turbines, central_platform_location)
    intersection = False
    # Left - 0
    # Right - 1
    # Colinear - 2
    for route in Routing:
        if arc[0] not in route:
            x3, y3 = give_coordinates(route[0], Wind_turbines, central_platform_location)
            x4, y4 = give_coordinates(route[1], Wind_turbines, central_platform_location)
            counter = 0
            Area = [0, 0, 0, 0]
            Position = [0, 0, 0, 0]
            Area[0] = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)
            Area[1] = (x2 - x1) * (y4 - y1) - (x4 - x1) * (y2 - y1)
            Area[2] = (x4 - x3) * (y1 - y3) - (x1 - x3) * (y4 - y3)
            Area[3] = (x4 - x3) * (y2 - y3) - (x2 - x3) * (y4 - y3)
            for i in range(4):
                if Area[i] > 0:
                    Position[i] = 0
                elif Area[i] < 0:
                    Position[i] = 1
                else:
                    Position[i] = 2
                    counter = counter + 1
            if Position[0] != Position[1] and Position[2] != Position[3] and counter <= 1:
                intersection = True
                break
    return intersection


def edge_crossings_area(arc, Wind_turbines, central_platform_location, Area_cross):
    x1, y1 = give_coordinates(arc[0], Wind_turbines, central_platform_location)
    x2, y2 = give_coordinates(arc[1], Wind_turbines, central_platform_location)
    intersection = False
    crossings = 0
    for area in Area_cross:
        counter = 0
        x3, y3 = area[0][0], area[0][1]
        x4, y4 = area[1][0], area[1][1]
        Area = [0, 0, 0, 0]
        Position = [0, 0, 0, 0]
        Area[0] = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)
        Area[1] = (x2 - x1) * (y4 - y1) - (x4 - x1) * (y2 - y1)
        Area[2] = (x4 - x3) * (y1 - y3) - (x1 - x3) * (y4 - y3)
        Area[3] = (x4 - x3) * (y2 - y3) - (x2 - x3) * (y4 - y3)
        for i in range(4):
            if Area[i] > 0:
                Position[i] = 0
            elif Area[i] < 0:
                Position[i] = 1
            else:
                Position[i] = 2
                counter = counter + 1
        if Position[0] != Position[1] and Position[2] != Position[3] and counter <= 1:
            intersection = True
            crossings = crossings + 1
    return intersection, crossings


# Plotting+Cable_length
def plotting(fig, central_platform_location1, Wind_turbines1, Routing, Routing_red, Routing_green, Capacityi,
             Cable_Costi):
    central_platform_location1_1 = [[0, central_platform_location1[0], central_platform_location1[1]]]
    Full_List = central_platform_location1_1 + Wind_turbines1
    Routing_blue = [i for i in Routing if i not in Routing_red]
    Routing_blue = [i for i in Routing_blue if i not in Routing_green]
    cable_length1blue = 0
    index, x, y = list(zip(*Full_List))
    ax = fig.add_subplot(111)
    plt.plot([p[1] for p in Wind_turbines1], [p[2] for p in Wind_turbines1], 'bo', ms=6)
    plt.plot([p[1] for p in central_platform_location1_1], [p[2] for p in central_platform_location1_1], 'ro', ms=10)
    ax.set_xlabel('x [km]', fontsize=fontsize2)
    ax.set_ylabel('y [km]', fontsize=fontsize2)
    arcs1 = []
    arcs2 = []
    for i in Routing_blue:
        for j in Full_List:
            if j[0] == i[0]:
                arcs1.append([j[1], j[2]])
            if j[0] == i[1]:
                arcs2.append([j[1], j[2]])
    for i in range(len(arcs1)):
        arcs1.insert(2 * i + 1, arcs2[i])
    for j in range(len(arcs1) - len(Routing_blue)):
        plt.plot([arcs1[2 * j][0], arcs1[2 * j + 1][0]], [arcs1[2 * j][1], arcs1[2 * j + 1][1]], color='b')
        cable_length1blue = cable_length1blue + hypot(arcs1[2 * j][0] - arcs1[2 * j + 1][0],
                                                      arcs1[2 * j][1] - arcs1[2 * j + 1][1])
    cable_cost = Cable_Costi[1] * (cable_length1blue)
    cable_length = cable_length1blue

    if len(Cable_Costi) == 2:
        cable_length1red = 0
        arcs1 = []
        arcs2 = []
        for i in Routing_red:
            for j in Full_List:
                if j[0] == i[0]:
                    arcs1.append([j[1], j[2]])
                if j[0] == i[1]:
                    arcs2.append([j[1], j[2]])
        for i in range(len(arcs1)):
            arcs1.insert(2 * i + 1, arcs2[i])
        for j in range(len(arcs1) - len(Routing_red)):
            plt.plot([arcs1[2 * j][0], arcs1[2 * j + 1][0]], [arcs1[2 * j][1], arcs1[2 * j + 1][1]], color='r')
            cable_length1red = cable_length1red + hypot(arcs1[2 * j][0] - arcs1[2 * j + 1][0],
                                                        arcs1[2 * j][1] - arcs1[2 * j + 1][1])
        cable_cost = Cable_Costi[1] * (cable_length1blue) + Cable_Costi[2] * (cable_length1red)
        cable_length = cable_length1blue + cable_length1red

    if len(Cable_Costi) == 3:

        cable_length1red = 0
        arcs1 = []
        arcs2 = []
        for i in Routing_red:
            for j in Full_List:
                if j[0] == i[0]:
                    arcs1.append([j[1], j[2]])
                if j[0] == i[1]:
                    arcs2.append([j[1], j[2]])
        for i in range(len(arcs1)):
            arcs1.insert(2 * i + 1, arcs2[i])
        for j in range(len(arcs1) - len(Routing_red)):
            plt.plot([arcs1[2 * j][0], arcs1[2 * j + 1][0]], [arcs1[2 * j][1], arcs1[2 * j + 1][1]], color='r')
            cable_length1red = cable_length1red + hypot(arcs1[2 * j][0] - arcs1[2 * j + 1][0],
                                                        arcs1[2 * j][1] - arcs1[2 * j + 1][1])

        cable_length1green = 0
        arcs1 = []
        arcs2 = []
        for i in Routing_green:
            for j in Full_List:
                if j[0] == i[0]:
                    arcs1.append([j[1], j[2]])
                if j[0] == i[1]:
                    arcs2.append([j[1], j[2]])
        for i in range(len(arcs1)):
            arcs1.insert(2 * i + 1, arcs2[i])
        for j in range(len(arcs1) - len(Routing_green)):
            plt.plot([arcs1[2 * j][0], arcs1[2 * j + 1][0]], [arcs1[2 * j][1], arcs1[2 * j + 1][1]], color='g')
            cable_length1green = cable_length1green + hypot(arcs1[2 * j][0] - arcs1[2 * j + 1][0],
                                                            arcs1[2 * j][1] - arcs1[2 * j + 1][1])
        cable_length = cable_length1blue + cable_length1red + cable_length1green
        cable_cost = Cable_Costi[1] * (cable_length1blue) + Cable_Costi[2] * (cable_length1red) + Cable_Costi[3] * (
        cable_length1green)
    plt.plot([p[1] for p in central_platform_location1_1], [p[2] for p in central_platform_location1_1], marker='o',
             ms=10, color='0.35')
    plt.plot([p[1] for p in Wind_turbines1], [p[2] for p in Wind_turbines1], 'o', ms=2, color='0.35')
    return cable_length, cable_cost, ax


def cable_cost(central_platform_location, Wind_turbinesi, Routing, Routing_red, Routing_green, Cable_Costi):
    Routing_blue = [i for i in Routing if i not in Routing_red]
    Routing_blue = [i for i in Routing_blue if i not in Routing_green]
    cable_length1blue = 0
    for route in Routing_blue:
        x1, y1 = give_coordinates(route[0], Wind_turbinesi, central_platform_location)
        x2, y2 = give_coordinates(route[1], Wind_turbinesi, central_platform_location)
        cable_length1blue = cable_length1blue + hypot(x2 - x1, y2 - y1)
    cable_cost = Cable_Costi[1] * (cable_length1blue)

    if len(Cable_Costi) == 2:
        cable_length1red = 0
        for route in Routing_red:
            x1, y1 = give_coordinates(route[0], Wind_turbinesi, central_platform_location)
            x2, y2 = give_coordinates(route[1], Wind_turbinesi, central_platform_location)
            cable_length1red = cable_length1red + hypot(x2 - x1, y2 - y1)
        cable_cost = Cable_Costi[1] * (cable_length1blue) + Cable_Costi[2] * (cable_length1red)

    if len(Cable_Costi) == 3:
        cable_length1red = 0
        for route in Routing_red:
            x1, y1 = give_coordinates(route[0], Wind_turbinesi, central_platform_location)
            x2, y2 = give_coordinates(route[1], Wind_turbinesi, central_platform_location)
            cable_length1red = cable_length1red + hypot(x2 - x1, y2 - y1)
        cable_length1green = 0
        for route in Routing_green:
            x1, y1 = give_coordinates(route[0], Wind_turbinesi, central_platform_location)
            x2, y2 = give_coordinates(route[1], Wind_turbinesi, central_platform_location)
            cable_length1green = cable_length1green + hypot(x2 - x1, y2 - y1)
        cable_cost = Cable_Costi[1] * (cable_length1blue) + Cable_Costi[2] * (cable_length1red) + Cable_Costi[3] * (
        cable_length1green)
    return cable_cost


# Submethods return x and y coordinates of a turbine if it's ID is known. The OHVS must also be included
def give_coordinates(turbineID, Wind_turbines, central_platform_location):
    if turbineID == 0:
        x = central_platform_location[0]
        y = central_platform_location[1]
    else:
        turbine = WT_List[turbineID - 1]
        x = turbine[1]
        y = turbine[2]
    return x, y


# ------------------------------------Run------------------------------------------------------------------
t0 = time.time()
set_cable_topology(NT, WT_List, central_platform_locations, Cable_List)
t1 = time.time()
print(('Elapsed time = {0} s'.format(round(t1 - t0, 3))))
